<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ä¸­ YouBike 2.0 æ‰¾è»Šåœ°åœ– (ä¿®æ­£ç‰ˆ)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        html, body { height: 100%; margin: 0; font-family: "Microsoft JhengHei", sans-serif; }
        .container { display: flex; flex-direction: column; height: 100%; }
        #map { flex: 1; z-index: 1; }
        #list-container { height: 40%; overflow-y: auto; background: white; border-top: 3px solid #f9be00; }
        table { width: 100%; border-collapse: collapse; }
        th { background: #f9be00; color: #333; position: sticky; top: 0; padding: 12px; z-index: 10; }
        td { padding: 12px 8px; border-bottom: 1px solid #eee; text-align: center; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
        .start-btn { padding: 15px 40px; font-size: 1.2rem; cursor: pointer; background: #f9be00; border: none; border-radius: 50px; font-weight: bold; }
    </style>
</head>
<body>

<div id="overlay">
    <div style="font-size: 60px;">ğŸš²</div>
    <h2>å°ä¸­ YouBike 2.0 æŸ¥è©¢ç³»çµ±</h2>
    <p>é»æ“ŠæŒ‰éˆ•æˆæ¬Šå®šä½ä¸¦è¼‰å…¥è·¯ç·šè³‡æ–™</p>
    <button class="start-btn" onclick="startApp()">é–‹å§‹ä½¿ç”¨</button>
</div>

<div class="container">
    <div id="map"></div>
    <div id="list-container">
        <table>
            <thead>
                <tr><th>ç«™é»åç¨±</th><th>è·é›¢</th><th>å¯å€Ÿ</th><th>å¯é‚„</th></tr>
            </thead>
            <tbody id="bikeList"></tbody>
        </table>
    </div>
</div>

<script>
// --- åœ°åœ–åˆå§‹åŒ– ---
const map = L.map('map').setView([24.1373, 120.6856], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

// --- è·é›¢èˆ‡è·¯å¾‘æ¼”ç®—æ³• ---

function calculateDistance(coord1, coord2) {
    const [lon1, lat1] = coord1;
    const [lon2, lat2] = coord2;
    const R = 6371000;
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
    const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * Math.sin(dLon / 2) ** 2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function findExtremeEndpoints(segments) {
    const endpoints = [];
    segments.forEach(segment => endpoints.push(segment[0], segment[segment.length - 1]));
    const scores = endpoints.map((endpoint, i) => {
        let score = 0;
        endpoints.forEach((other, j) => { if (i !== j) score += calculateDistance(endpoint, other); });
        return { point: endpoint, score };
    });
    scores.sort((a, b) => b.score - a.score);
    return [scores[0].point, scores[1].point];
}

function connectSegments(segments, extremeEndpoints) {
    const [extremeStart, extremeEnd] = extremeEndpoints;
    let path = [extremeStart];
    let currentPoint = extremeStart;
    const gapTolerance = 50; 

    while (segments.length > 0) {
        let closestIndex = -1, closestSegment = null, closestDistance = Infinity, reverse = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i], start = segment[0], end = segment[segment.length - 1];
            const distStart = calculateDistance(currentPoint, start), distEnd = calculateDistance(currentPoint, end);
            if (distStart < closestDistance) { closestDistance = distStart; closestIndex = i; closestSegment = segment; reverse = false; }
            if (distEnd < closestDistance) { closestDistance = distEnd; closestIndex = i; closestSegment = segment; reverse = true; }
        }
        if (closestSegment) {
            if (reverse) closestSegment.reverse();
            if (closestDistance <= gapTolerance) {
                path.push([(currentPoint[0] + closestSegment[0][0]) / 2, (currentPoint[1] + closestSegment[0][1]) / 2]);
            }
            path.push(...closestSegment);
            currentPoint = path[path.length - 1];
            segments.splice(closestIndex, 1);
        } else { break; }
    }
    return path;
}

function processGeoJSON(geojson) {
    geojson.features = geojson.features.map(feature => {
        if (feature.geometry.type === 'MultiLineString') {
            const segments = feature.geometry.coordinates;
            const extremeEndpoints = findExtremeEndpoints(segments);
            const orderedCoordinates = connectSegments(segments, extremeEndpoints);
            feature.geometry = { type: 'LineString', coordinates: orderedCoordinates };
        }
        return feature;
    });
    return geojson;
}

// --- ä¸»è¦åŸ·è¡Œé‚è¼¯ ---

async function startApp() {
    document.getElementById('overlay').style.display = 'none';
    
    navigator.geolocation.getCurrentPosition(async (pos) => {
        const uLat = pos.coords.latitude;
        const uLng = pos.coords.longitude;
        map.setView([uLat, uLng], 15);
        L.marker([uLat, uLng]).addTo(map).bindPopup("<b>æ‚¨çš„ä½ç½®</b>").openPopup();

        // å‘¼å«æŠ“å–ç«™é»å‡½å¼
        await fetchBikeData(uLat, uLng);

        // è¼‰å…¥ GeoJSON è·¯ç·š (å¦‚æœæœ‰çš„è©±)
        try {
            const geoResponse = await fetch('Route20OK.geojson');
            if (geoResponse.ok) {
                let geojsonData = await geoResponse.json();
                geojsonData = processGeoJSON(geojsonData);
                L.geoJSON(geojsonData, { style: { color: "#ff4757", weight: 6, opacity: 0.8 } }).addTo(map);
            }
        } catch (err) { console.log("GeoJSON è¼‰å…¥è·³é"); }

    }, (err) => {
        alert("å®šä½å¤±æ•—ï¼Œè«‹ç¢ºèªæ˜¯å¦é–‹å•Ÿ GPS èˆ‡ HTTPS é€£ç·š");
    });
}

// ä¿®æ­£å¾Œçš„æŠ“å–ç«™é»å‡½å¼
async function fetchBikeData(uLat, uLng) {
    const tbody = document.getElementById('bikeList');
    tbody.innerHTML = '<tr><td colspan="4">è³‡æ–™åŠ è¼‰ä¸­...</td></tr>';
    
    try {
        const api = "https://ybjson02.youbike.com.tw:60008/yb2/taichung/gwjs.json";
        const proxy = `https://corsproxy.io/?${encodeURIComponent(api)}`;
        
        const res = await fetch(proxy);
        if (!res.ok) throw new Error("é€£ç·šå¤±æ•—");
        
        const json = await res.json();
        const data = json.retVal; // å®˜æ–¹è³‡æ–™åœ¨ retVal è£¡é¢

        // è™•ç†ä¸¦æ’åº
        const stations = Object.keys(data).map(k => {
            const s = data[k];
            const sLat = parseFloat(s.lat);
            const sLng = parseFloat(s.lng);
            return {
                name: s.sna.replace("YouBike2.0_", ""),
                lat: sLat,
                lng: sLng,
                sbi: parseInt(s.sbi), // å¯å€Ÿ
                bemp: parseInt(s.bemp), // å¯é‚„
                // ä¿®æ­£åº§æ¨™å‚³éé †åºï¼š[ç¶“åº¦, ç·¯åº¦]
                dist: calculateDistance([uLng, uLat], [sLng, sLat])
            };
        })
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 25); // å–æœ€è¿‘ 25 ç«™

        tbody.innerHTML = "";
        stations.forEach(s => {
            // åœ¨åœ°åœ–ä¸ŠåŠ ä¸Šæ¨™è¨˜
            L.marker([s.lat, s.lng]).addTo(map)
                .bindPopup(`<b>${s.name}</b><br>ğŸš² å¯å€Ÿï¼š${s.sbi}<br>ğŸ…¿ï¸ å¯é‚„ï¼š${s.bemp}`);

            // å¯«å…¥è¡¨æ ¼
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td style="text-align:left">${s.name}</td>
                <td>${Math.round(s.dist)}m</td>
                <td style="color:${s.sbi > 0 ? 'green' : 'red'}; font-weight:bold;">${s.sbi}</td>
                <td>${s.bemp}</td>
            `;
            tbody.appendChild(tr);
        });
    } catch (e) {
        console.error(e);
        tbody.innerHTML = '<tr><td colspan="4" style="color:red">ç„¡æ³•å–å¾—å®˜æ–¹ API è³‡æ–™</td></tr>';
    }
}
</script>
</body>
</html>
